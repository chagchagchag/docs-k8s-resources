{"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/advanced":{"title":"Advanced","data":{"":"This is the index page for the Advanced folder!"}},"/storage/PV-PVC":{"title":"Pv Pvc","data":{}},"/":{"title":"Introduction","data":{"":"시간 나는 대로 조금씩 채워가는 페이지입니다."}},"/advanced/satori":{"title":"Satori","data":{"":"Satori (悟り) is a Japanese Buddhist term for awakening, \"comprehension; understanding\"."}},"/storage/window-directory-k8s-mount":{"title":"kubernetes hostPath 지정시 윈도우 WSL 디렉터리 경로","data":{"참고자료#참고자료":"Kubernetes on docker for windows, persistent volume with hostPath gives Operation not permitted\nWSL2 Kubernetes 환경에서 Windows 경로 Mount 하기\nKubernetes how to correctly mount windows path in wsl2 backed environment\nWindows 10 20H2 Docker Desktop WSL2 enable 환경에서 Kubernetes volume hostPath 연결 오류 해결\nKubernetes on docker for windows, persistent volume with hostPath gives Operation not permitted\nwsl2 kubernetes volume hostpath 못잡는 문제 해결방법\nhttps://www.inflearn.com/questions/98495/access-i-s-denied-문제\nError response from daemon: mkdir C:\\Program Files\\Git\\opt: Access is denied\npath for PersistentVolume in Kubernetes .yaml in Windows","윈도우os-에서-hostpath-경로#윈도우OS 에서 hostPath 경로":"쿠버네티스 역시 결국은 Docker 엔진으로 동작하는데, 윈도우 기반의 Docker 엔진에서 WSL 의 어느 디렉터리를 참조하는지가 꽤 까다롭습니다.\r\n디렉터리를 참조하는 경로는 아래와 같이 구성됩니다.\n/run/desktop/mnt/host/c/PATH/TO/FILE\n예를 들어 HOST PC 의 /v/000.env/volume 을 파드 내에서 마운트할 때 hostPath 의 path 는 아래와 같이 지정해줍니다.\n/run/desktop/mnt/host/v/000.env/volume"}},"/another":{"title":"Another Page","data":{"":"let a = 1;\r\n\r\nconsole.log(a);","component#Component":"","external-component#External Component":""}},"/storage/hostPath-emptyDir":{"title":"hostPath, emptyDir","data":{"":"hostPath는 노드(호스트)의 디렉터리를 파드에 마운트하는 방식이고, emptyDir 은 노드(호스트)의 디스크를 컨테이너의 볼륨으로 마운트하는 방식이다.\r\nhostPath 는 파드가 재시작되더라도 노드(호스트)에 데이터가 남아있다. 다만 파드가 다른 노드에서 재시작 되면 이전에 사용했던 데이터를 이용하는 것은 불가능하다.\r\nemptyDir 은 파드가 살아있는 동안 컨테이너가 장애 등으로 인해 재기동되더라도 컨테이너는 파드가 마운트하고 있는 emptyDir 을 그대로 이어서 사용 가능하다. 다만 파드가 소멸되면 emptyDir 볼륨 내의 데이터도 소멸된다.\nhostPath, emptyDir 은 지역적인 볼륨의 개념이라고 생각한다면 이해가 쉽다.\r\n즉 hostPath, emptyDir 은 하나의 노드 또는 하나의 파드 내서만의 볼륨을 사용하는 개념이다.\r\n뒤에서 따로 정리할 PV/PVC 문서에서는 여러 노드가 공유할 수 있는 볼륨을 쿠버네티스의 PV 리소스로 선언하고 PVC를 통해 접근하는 예제와 개념들을 정리할 예정이다.\nPV 역시 PV를 hostPath 기반으로 선언할 수도 있고, NFS 기반으로 선언할 수도 있고, AWSElasticBlockStore PV 로도 선언할 수 있다.\r\n가장 선호되는 방식은 AWSElasticBlockStore 방식이겠지만, 경우에 따라 취사선택을 하는 경우가 많다.","hostpath#hostPath":"hostPath 는 노드(호스트 머신)의 디렉터리를 파드에 마운트하는 방식이다. 위에서 살펴본 emptyDir 은 컨테이너의 볼륨으로 호스트의 디스크를 마운트하지만, hostPath 는 파드에 호스트의 디렉터리를 마운트한다는 사실에 유의하자.\n“파드가 Host 의 Path 를 마운트한다.” 라고 생각한다면 이해가 쉽다.\nhostPath 로 볼륨을 마운트하면 파드가 재시작 되더라도 호스트에 데이터가 남아있다. 다만 파드가 새로운 호스트(노드)에서 재시작될 경우는 새로운 호스트(노드)의 디렉터리를 사용하므로, 이전 노드에서 사용하던 데이터는 접근불가능하다.\nhostPath 는 흔히 Host Volume 이라고 부르기도 한다. 도커의 -v 옵션과 유사하게 host 서버의 볼륨 공간에 Pod가 데이터를 저장하는 것을 의미한다.","예제#예제":"Dockerhub - chagchagchag/k8shelloboot\ngithub/chagchagchag/eks-k8s-docker-study-archive/application-examples/k8shello\nk8s/k8shelloboot-hostpath.yml\nk8s/k8shelloboot-emptydir.yml\napiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: k8shelloboot-app-hostpath\r\nspec:\r\n  containers:\r\n  - name: k8shelloboot-app-hostpath\r\n    image: chagchagchag/k8shelloboot:0.0.1\r\n\r\n    # 컨테이너 내부의 연결 위치 지정\r\n    volumeMounts:\r\n    - mountPath: /app/volume\r\n      name: v-volume\r\n\r\n  # host 서버의 연결 위치 지정\r\n  volumes:\r\n  - name: v-volume\r\n    hostPath:\r\n      path: /run/desktop/mnt/host/v/000.env/volume\r\n      # type: DirectoryOrCreate\nvolumeMounts : 컨테이너 내부에서 사용될 볼륨을 선언\nmountPath: 컨테이너 내부에 볼륨이 연결될 위치를 지정. 컨테이너 내부의 운영체제 내의 /app/volume 디렉터리에 볼륨이 마운트된다.\nname: volumeMounts와 volume 을 연결하는 식별자로 사용된다. 위의 예제에서는 v-volume 이다.\nvolumes : Pod 에서 사용할 volume 을 지정\nname: volumeMounts 와 volume 을 연결하는 식별자로 사용. 위의 예제에서는 v-volume 이다.\nhostPath : 호스트 서버 내에 연결 위치를 지정. 위의 예제에서는 /run/desktop/mnt/host/v/000.env/volume 이다.","실행--확인#실행 & 확인":"$ kubectl apply -f k8shelloboot-hostpath.yml\r\npod/k8shelloboot-app-hostpath created\r\n\r\n$ kubectl exec -it k8shelloboot-app-hostpath -- bash\r\nbash-4.2#\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n# 정상적으로 출력됨을 확인 가능\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-30T11:27:27.320095147>>> write OK\r\n\r\nbash-4.2# exit\r\nexit\r\n\r\n## 삭제\r\n$ kubectl delete -f k8shelloboot-hostpath.yml\r\npod \"k8shelloboot-app-hostpath\" deleted\r\n\r\n## 재생성\r\n$ kubectl apply -f k8shelloboot-hostpath.yml\r\npod/k8shelloboot-app-hostpath created\r\n\r\n## bash 접속\r\n$ kubectl exec -it k8shelloboot-app-hostpath -- bash\r\nbash-4.2#\r\n\r\n## API 호출\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-30T11:27:27.320095147>>> write OK\r\n2024-01-30T11:27:34.827718406>>> write OK\r\nbash-4.2#","emptydir#emptyDir":"emptyDir 은 노드(호스트 머신)의 디스크를 컨테이너의 볼륨으로 마운트해서 사용하는 방식이다.\n파드가 소멸될 때 emptyDir 에 할당했던 볼륨 내의 데이터도 소멸된다.\n파드가 살아있는 동안은 컨테이너가 장애 등으로 인해 재기동 되더라도 컨테이너는 파드가 마운트하고 있는 emptyDir 을 그대로 사용 가능하다. 다만, 위에서도 이야기했듯 파드가 소멸되면 emptyDir 볼륨 내의 데이터도 소멸된다.\n리소스 정의 파일 작성 시 볼륨을 선언하는 구문과 컨테이너에서 볼륨을 마운트하는 구문을 따로 정의한다는 사실을 기억해야 한다.\n위에서 정리한 hostPath 는 노드(호스트) 레벨이라면, emptyDir은 파드레벨이라는 점을 떠올리면 이해가 쉽다.","예제-1#예제":"apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: k8shelloboot-app-emptydir\r\nspec:\r\n  containers:\r\n  - name: k8shelloboot-app-emptydir\r\n    image: chagchagchag/k8shelloboot:0.0.1\r\n\r\n    # 컨테이너 내부의 연결 위치 지정\r\n    volumeMounts:\r\n    - mountPath: /app/volume\r\n      name: v-volume\r\n\r\n  # host 서버의 연결 위치 지정\r\n  volumes:\r\n  - name: v-volume\r\n    emptyDir: {}","실행--확인-1#실행 & 확인":"$ kubectl apply -f k8shelloboot-emptyDir.yml\r\npod/k8shelloboot-app-emptydir created\r\n\r\n$ kubectl get all\r\nNAME                            READY   STATUS    RESTARTS   AGE\r\npod/k8shelloboot-app-emptydir   1/1     Running   0          11s\r\n\r\nNAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\r\nservice/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   13h\r\n\r\n$ kubectl exec -it k8shelloboot-app-emptydir -- bash\r\n\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-31T00:53:34.497769035>>> write OK\r\n\r\n\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-31T00:53:34.497769035>>> write OK\r\n2024-01-31T00:54:05.518777545>>> write OK\r\n\r\nbash-4.2# exit\r\nexit\r\n\r\n$ kubectl delete -f k8shelloboot-emptyDir.yml\r\npod \"k8shelloboot-app-emptydir\" deleted\r\n\r\n$ kubectl apply -f k8shelloboot-emptyDir.yml\r\npod/k8shelloboot-app-emptydir created\r\n\r\n$ kubectl exec -it k8shelloboot-app-emptydir -- bash\r\nbash-4.2#\r\n\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\ncat: /app/volume/cache-log.log: No such file or directory\r\n\r\n\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-31T00:56:46.765727615>>> write OK\r\n\r\n\r\nbash-4.2# exit\r\nexit"}}}