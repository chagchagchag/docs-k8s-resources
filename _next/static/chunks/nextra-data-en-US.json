{"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/advanced":{"title":"Advanced","data":{"":"This is the index page for the Advanced folder!"}},"/":{"title":"Introduction","data":{"":"시간 나는 대로 조금씩 채워가는 페이지입니다."}},"/advanced/satori":{"title":"Satori","data":{"":"Satori (悟り) is a Japanese Buddhist term for awakening, \"comprehension; understanding\"."}},"/storage/PV-PVC":{"title":"Pv Pvc","data":{"pv-pvc#PV, PVC":"","참고자료#참고자료":"Kubernetes - Volumes\n핵심만 콕! 쿠버네티스","pv-pvc-1#PV, PVC":"쿠버네티스에서는 데이터 저장소를 프로비저닝 쿠버네티스에서는 데이터 저장소를 프로비저닝(Provisioning(제공))하는 부분과 저장소를 사용하는 부분으로 분류합니다. PV는 프로비저닝을 담당하고, PVC는 저장소를 사용하는 역할을 합니다.\r\n즉, PV를 하나의 볼륨으로만 인식할 뿐이고, PVC를 거쳐서 PV에 Read/Write 를 수행합니다.\r\nPV 로 특정 볼륨을 마운트한 컨테이너는 새로운 노드에서 컨테이너/파드가 새로 기동되더라도 PV 볼륨에 저장된 데이터를 이어서 계속 사용가능합니다.\nPV 는 hostPath 기반으로 선언할 수도 있고, NFS 기반으로 선언할 수도 있고, AWSElasticBlockStore PV 로도 선언할 수 있습니다.\r\n이 외에도 다양한 방식으로 사용될 수 있는데 아래와 같은 다양한 방벋들이 있습니다.\nazureDisk : Azure 클라우드 플랫폼에서 제공하는 볼륨 서비스\nemptyDir : Pod 레벨에서의 볼륨개념이다. 주로 같은 Pod 내 컨테이너 들 끼리 filesystem을 통한 정보를 주고받을때 많이 사용한다.\ndownward API\nconfigMap\nAWS 클라우드 플랫폼 기반이라면 가장 선호되는 방식은 AWSElasticBlockStore 방식이겠지만, 경우에 따라 취사선택을 하는 경우가 많습니다.\r\n클라우드에서 제공하는 볼륨 서비스로는 GCP플랫폼에서는 PersistentDisk, AWS플랫폼에서는 EBS(Elastic Bock Storage) 라는 볼륨을 사용하는 방식이 있습니다.\nPVC 는 Persistent Volume Claim 의 약자로 PV 리소스를 요청하는 역할을 수행합니다. 클러스터 관리자가 PersistentVolume 을 통해 데이터 저장소를 준비하면 쿠버네티스 사용자(애플리케이션 개발자)가 PVC 요청을 통해 해당 리소스를 선점합니다.","pv-pvc-리소스-선언#PV, PVC 리소스 선언":"PV\nkind 를 PersistentVolume 으로 선언하고 세부적인 spec 내에 용량은 어느 정도로 할지 액세스 모드는 어떻게 할 것인지를 명시해서 하나의 리소스로 정의합니다.\nspec.capacity.storage 에 지정하는 저장 단위는 Gi, Mi 가 있다.\nPVC\nspec.storageClassName 에 어떤 종류의 저장소 타입을 지정할지를 지정합니다.\nspec.resources[i].requests.storage 에 어느 정도의 크기의 저장소를 지정할지를 명시합니다.\nspec.accessModes 에는 접근 모드를 설정합니다. NFS 를 사용할 경우 ReadWirteMany를 사용하기도 합니다.","hostpath-pv-pvc-예제#hostPath PV, PVC 예제":"apiVersion: v1\r\nkind: PersistentVolume\r\nmetadata:\r\n  name: k8shelloboot-pv-hostpath\r\nspec:\r\n  storageClassName: manual # 저장소 타입 지정\r\n  capacity: # 저장소 크기 \r\n    storage: 500Mi\r\n  accessModes: # 접근 모드 \r\n    - ReadWriteOnce # 동시에 1개의 파드만 볼륨에 접근할 수 있다\r\n  hostPath:\r\n    path: /run/desktop/mnt/host/v/000.env/volume\n이렇게 만든 PV 는 아래와 같이 확인 가능합니다.\n$ kubectl get pv\r\nNAME                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\r\nk8shelloboot-pv-hostpath   500Mi      RWO            Retain           Available           manual                  4s\n이번에는 PVC 를 생성합니다.\napiVersion: v1\r\nkind: PersistentVolumeClaim\r\nmetadata:\r\n  name: k8shelloboot-pvc-hostpath\r\nspec:\r\n  storageClassName: manual\r\n  resources:\r\n    requests:\r\n      storage: 500Mi\r\n  accessModes:\r\n    - ReadWriteOnce\n생성한 PVC 를 적용해봅니다.\n$ kubectl apply -f k8shelloboot-pvc-hostpath.yml\r\npersistentvolumeclaim/k8shelloboot-pvc-hostpath created\n이번에는 PV가 잘 연결되었는지 확인해봅니다.\n$ kubectl get pv\r\nNAME                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                               STORAGECLASS   REASON   AGE\r\nk8shelloboot-pv-hostpath   500Mi      RWO            Retain           Bound    default/k8shelloboot-pvc-hostpath   manual                  3m1s\nPVC 연결 전에는 STATUS 가 Available 였는데 연결 후에는 STATUS가 Bound 로 변한 것을 확인 가능합니다.","nfs-pv-pvc-예제#NFS PV, PVC 예제":"nfs 는 StorageClass 와 nfs-server-provisioner 를 이용한 실습이 가능한데, 이 것에 대해서는 나중에 정리해둘 예정이고, 일단은 PV 리소스 정의를 어떻게 하는지만 정리해두었습니다.\napiVersion: v1\r\nkind: PersistentVolume\r\nmetadata:\r\n  name: k8shello-pv-nfs\r\nspec:\r\n  storageClassName: nfs # 저장소 타입 지정\r\n  capacity: # 저장소 크기 지정\r\n    storage: 500Mi\r\n  accessModes: # 접근 모드 \r\n    - ReadWriteMany # nfs 는 ReadWriteMany 로 여러 Pod 에서 접근이 가능 \r\n  mountOptions:\r\n    - hard\r\n    - nfsvers=4.1\r\n  nfs:\r\n    path: /tmp/nfs\r\n    server: <NFS 서버 IP>","ebs-pv-예제#EBS PV 예제":"apiVersion: v1\r\nkind: PersistentVolume\r\nmetadata:\r\n  name: k8shelloboot-pv-ebs\r\nspec:\r\n  capacity:\r\n    storage: 1Gi # 데이터 저장소 크기 \r\n  accessModes: # 접근모드\r\n    - ReadWriteOnce\r\n  awsElasticBlockStore: # AWS EBS 정보 입력\r\n    volumeID: <Volume ID>\r\n    fsType: ext4"}},"/another":{"title":"Another Page","data":{"":"let a = 1;\r\n\r\nconsole.log(a);","component#Component":"","external-component#External Component":""}},"/storage/hostPath-emptyDir":{"title":"hostPath, emptyDir","data":{"":"hostPath는 노드(호스트)의 디렉터리를 파드에 마운트하는 방식이고, emptyDir 은 노드(호스트)의 디스크를 컨테이너의 볼륨으로 마운트하는 방식이다.\r\nhostPath 는 파드가 재시작되더라도 노드(호스트)에 데이터가 남아있다. 다만 파드가 다른 노드에서 재시작 되면 이전에 사용했던 데이터를 이용하는 것은 불가능하다.\r\nemptyDir 은 파드가 살아있는 동안 컨테이너가 장애 등으로 인해 재기동되더라도 컨테이너는 파드가 마운트하고 있는 emptyDir 을 그대로 이어서 사용 가능하다. 다만 파드가 소멸되면 emptyDir 볼륨 내의 데이터도 소멸된다.\nemptyDir 은 Pod 레벨의 생명주기를 가진 임시저장소다. hostPath 는 호스트(노드) 레벨에서의 볼륨이다.\r\nhostPath는 노드 레벨, emptyDir 은 파드 레벨에서의 지역적인 볼륨의 개념이라고 생각한다면 이해가 쉽다.\r\n즉 hostPath, emptyDir 은 하나의 노드 또는 하나의 파드 내에서만의 볼륨을 사용하는 개념이다.뒤에서 따로 정리할 PV/PVC 문서에서는 여러 노드가 공유할 수 있는 볼륨을 쿠버네티스의 PV 리소스로 선언하고 PVC를 통해 접근하는 예제와 개념들을 살펴본다.\r\nhostPath, emptyDir 모두 PV 로 선언할 수 있기는 하다.\r\n하지만, NFS, AWSElasticBlockStore 기반의 볼륨으로 사용하는 것이 더 권장되는 방식이다.","예제#예제":"Dockerhub - chagchagchag/k8shelloboot\ngithub/chagchagchag/eks-k8s-docker-study-archive/application-examples/k8shello\nk8s/k8shelloboot-hostpath.yml\nk8s/k8shelloboot-emptydir.yml","hostpath#hostPath":"hostPath 는 노드(호스트 머신)의 디렉터리를 파드에 마운트하는 방식이다. 위에서 살펴본 emptyDir 은 호스트의 디스크를 컨테이너의 볼륨으로 마운트하지만, hostPath 는 호스트의 디스크를 파드에 마운트한다는 사실에 유의하자.\n“파드가 Host 의 Path 를 마운트한다.” 라고 생각한다면 이해가 쉽다.\nhostPath 로 볼륨을 마운트하면 파드가 재시작 되더라도 호스트에 데이터가 남아있다. 다만 파드가 새로운 호스트(노드)에서 재시작될 경우는 새로운 호스트(노드)의 디렉터리를 사용하므로, 이전 노드에서 사용하던 데이터는 접근불가능하다.\nhostPath 는 흔히 Host Volume 이라고 부르기도 한다. 도커의 -v 옵션과 유사하게 host 서버의 볼륨 공간에 Pod가 데이터를 저장하는 것을 의미한다.\napiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: k8shelloboot-app-hostpath\r\nspec:\r\n  containers:\r\n  - name: k8shelloboot-app-hostpath\r\n    image: chagchagchag/k8shelloboot:0.0.1\r\n\r\n    # 컨테이너 내부의 연결 위치 지정\r\n    volumeMounts:\r\n    - mountPath: /app/volume\r\n      name: v-volume\r\n\r\n  # host 서버의 연결 위치 지정\r\n  volumes:\r\n  - name: v-volume\r\n    hostPath:\r\n      path: /run/desktop/mnt/host/v/000.env/volume\r\n      # type: DirectoryOrCreate\nvolumeMounts : 컨테이너 내부에서 사용될 볼륨을 선언\nmountPath: 컨테이너 내부에 볼륨이 연결될 위치를 지정. 컨테이너 내부의 운영체제 내의 /app/volume 디렉터리에 볼륨이 마운트된다.\nname: volumeMounts와 volume 을 연결하는 식별자로 사용된다. 위의 예제에서는 v-volume 이다.\nvolumes : Pod 에서 사용할 volume 을 지정\nname: volumeMounts 와 volume 을 연결하는 식별자로 사용. 위의 예제에서는 v-volume 이다.\nhostPath : 호스트 서버 내에 연결 위치를 지정. 위의 예제에서는 /run/desktop/mnt/host/v/000.env/volume 이다.","실행--확인#실행 & 확인":"$ kubectl apply -f k8shelloboot-hostpath.yml\r\npod/k8shelloboot-app-hostpath created\r\n\r\n$ kubectl exec -it k8shelloboot-app-hostpath -- bash\r\nbash-4.2#\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n# 정상적으로 출력됨을 확인 가능\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-30T11:27:27.320095147>>> write OK\r\n\r\nbash-4.2# exit\r\nexit\r\n\r\n## 삭제\r\n$ kubectl delete -f k8shelloboot-hostpath.yml\r\npod \"k8shelloboot-app-hostpath\" deleted\r\n\r\n## 재생성\r\n$ kubectl apply -f k8shelloboot-hostpath.yml\r\npod/k8shelloboot-app-hostpath created\r\n\r\n## bash 접속\r\n$ kubectl exec -it k8shelloboot-app-hostpath -- bash\r\nbash-4.2#\r\n\r\n## API 호출\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-30T11:27:27.320095147>>> write OK\r\n2024-01-30T11:27:34.827718406>>> write OK\r\nbash-4.2#","emptydir#emptyDir":"emptyDir 은 노드(호스트 머신)의 디스크를 컨테이너의 볼륨으로 마운트해서 사용하는 방식이다.\n파드가 소멸될 때 emptyDir 에 할당했던 볼륨 내의 데이터도 소멸된다.\n파드가 살아있는 동안은 컨테이너가 장애 등으로 인해 재기동 되더라도 컨테이너는 파드가 마운트하고 있는 emptyDir 을 그대로 사용 가능하다. 다만, 위에서도 이야기했듯 파드가 소멸되면 emptyDir 볼륨 내의 데이터도 소멸된다.\n리소스 정의 파일 작성 시 볼륨을 선언하는 구문과 컨테이너에서 볼륨을 마운트하는 구문을 따로 정의한다는 사실을 기억해야 한다.\n위에서 정리한 hostPath 는 노드(호스트) 레벨이라면, emptyDir은 파드레벨이라는 점을 떠올리면 이해가 쉽다.","예제-1#예제":"apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: k8shelloboot-app-emptydir\r\nspec:\r\n  containers:\r\n  - name: k8shelloboot-app-emptydir\r\n    image: chagchagchag/k8shelloboot:0.0.1\r\n\r\n    # 컨테이너 내부의 연결 위치 지정\r\n    volumeMounts:\r\n    - mountPath: /app/volume\r\n      name: v-volume\r\n\r\n  # host 서버의 연결 위치 지정\r\n  volumes:\r\n  - name: v-volume\r\n    emptyDir: {}","실행--확인-1#실행 & 확인":"$ kubectl apply -f k8shelloboot-emptyDir.yml\r\npod/k8shelloboot-app-emptydir created\r\n\r\n$ kubectl get all\r\nNAME                            READY   STATUS    RESTARTS   AGE\r\npod/k8shelloboot-app-emptydir   1/1     Running   0          11s\r\n\r\nNAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\r\nservice/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   13h\r\n\r\n$ kubectl exec -it k8shelloboot-app-emptydir -- bash\r\n\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-31T00:53:34.497769035>>> write OK\r\n\r\n\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-31T00:53:34.497769035>>> write OK\r\n2024-01-31T00:54:05.518777545>>> write OK\r\n\r\nbash-4.2# exit\r\nexit\r\n\r\n$ kubectl delete -f k8shelloboot-emptyDir.yml\r\npod \"k8shelloboot-app-emptydir\" deleted\r\n\r\n$ kubectl apply -f k8shelloboot-emptyDir.yml\r\npod/k8shelloboot-app-emptydir created\r\n\r\n$ kubectl exec -it k8shelloboot-app-emptydir -- bash\r\nbash-4.2#\r\n\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\ncat: /app/volume/cache-log.log: No such file or directory\r\n\r\n\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-01-31T00:56:46.765727615>>> write OK\r\n\r\n\r\nbash-4.2# exit\r\nexit"}},"/storage/storage-class":{"title":"Storage Class","data":{"storageclass#StorageClass":"","local-path#local-path":"kind 에는 local-path 타입의 StorageClass 가 설치되어 있습니다. kind 클러스터의 버전에 따라 다르겠지만, 이번 예제에서 사용한 kind 클러스터에서 나타난 local-path 타입의 StorageClass 의 이름은 standard 라는 이름으로 설치되어 있습니다.\r\nStorageClass 를 조회하는 명령은 kubectl get sc 입니다.\n$ kubectl get sc\r\nNAME                 PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE\r\nstandard (default)   rancher.io/local-path   Delete          WaitForFirstConsumer   false                  11m\n위의 결과를 보면 Kind 클러스터 내에 local-path 타입으로 디폴트로 설치된 StorageClass 의 이름은 \"standard\" 입니다.\r\n아래에서 정의할 PVC 정의 yaml 에서 spec.storageClassName 은 반드시 위에서 조회해서 알게된 standard 로 지정해주면 됩니다.\n어떻게 정의되어 있는지 확인해보면 아래와 같습니다.\n$ kubectl get sc standard -oyaml\r\napiVersion: storage.k8s.io/v1\r\nkind: StorageClass\r\nmetadata:\r\n  annotations:\r\n    kubectl.kubernetes.io/last-applied-configuration: |\r\n      {\"apiVersion\":\"storage.k8s.io/v1\",\"kind\":\"StorageClass\",\"metadata\":{\"annotations\":{\"storageclass.kubernetes.io/is-default-class\":\"true\"},\"name\":\"standard\"},\"provisioner\":\"rancher.io/local-path\",\"reclaimPolicy\":\"Delete\",\"volumeBindingMode\":\"WaitForFirstConsumer\"}\r\n    storageclass.kubernetes.io/is-default-class: \"true\"\r\n  creationTimestamp: \"2024-02-01T07:44:21Z\"\r\n  name: standard\r\n  resourceVersion: \"286\"\r\n  uid: 5b06a540-194d-4f69-b93b-6435b761812b\r\nprovisioner: rancher.io/local-path\r\nreclaimPolicy: Delete\r\nvolumeBindingMode: WaitForFirstConsumer\n이번에는 local-path 타입의 pvc 를 한번 만들어보겠습니다.\napiVersion: v1\r\nkind: PersistentVolumeClaim\r\nmetadata:\r\n  name: k8shelloboot-pvc-local-path\r\nspec:\r\n  storageClassName: standard # kubectl get sc 명령을 통해 나타나는 storeclass 중 하나를 선택했다.\r\n  # storageClassName: local-path\r\n  # storageClassName: \"\"\r\n  accessModes:\r\n    - ReadWriteOnce\r\n  resources:\r\n    requests:\r\n      storage: 500Mi\r\nspec.storageClassName\nkubectl get sc 명령을 통해 나타나는 StorageClass 목록에서 원하는 StorageClass 를 선택합니다.\n이번 문서의 제일 처음에 kind 클러스터에서 StorageClass 중 설치된 것이 있는지 조회해봤고 standard 가 default 였기에 storageClassName 을 standard 로 지정해줬습니다.\nkubectl apply 를 통해 적용해봅니다.\n$ kubectl apply -f k8shelloboot-pvc-local-path.yml\r\npersistentvolumeclaim/k8shelloboot-pvc-local-path created\n만들어진 pvc 를 확인해보겠습니다.\n$ kubectl get pvc\r\nNAME                          STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\r\nk8shelloboot-pvc-local-path   Pending                                      local-path     10s\n현재 Pending 상태입니다. Pod가 PVC를 사용할 때 동적으로 볼륨이 생성됩니다.\ndeployment 를 기동해보기 위해 아래의 deployment 정의서를 작성합니다.\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: k8shelloboot-app-deploy\r\nspec:\r\n  selector:\r\n    matchLabels:\r\n      app: k8shelloboot-app\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: k8shelloboot-app\r\n    spec:\r\n      volumes:\r\n        # 1)\r\n        - name: log-volume\r\n          persistentVolumeClaim:\r\n            claimName: k8shelloboot-pvc-local-path\r\n      containers:\r\n      - name: k8shelloboot\r\n        image: chagchagchag/k8shelloboot:0.0.1\r\n        imagePullPolicy: Always\r\n        volumeMounts:\r\n          - mountPath: /app/volume\r\n            name: log-volume\r\n        ports:\r\n        - containerPort: 8080\n1)\nspec.volumes 내에 volume 을 하나 추가해줬습니다.\nvolume 의 이름(name)은 log-volume 이라고 정의해줬고, persistentVolumeClame.clameName 을 지정해서 사용하려는 PersistentVolumeClaim 의 이름을 명시했습니다.\n작성한 리소스 정의서를 kubectl 을 통해 kubernetes 클러스터에 적용합니다.\n$ kubectl apply -f k8shelloboot-deploy.yml\r\ndeployment.apps/k8shelloboot-app-deploy created\ndeployment 가 제대로 구동되었는지 확인해보겠습니다.\n$ kubectl get all\r\nNAME                                           READY   STATUS    RESTARTS   AGE\r\npod/k8shelloboot-app-deploy-7f67896bf7-wqxs9   1/1     Running   0          7s\r\n\r\nNAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\r\nservice/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   54m\r\n\r\nNAME                                      READY   UP-TO-DATE   AVAILABLE   AGE\r\ndeployment.apps/k8shelloboot-app-deploy   1/1     1            1           7s\r\n\r\nNAME                                                 DESIRED   CURRENT   READY   AGE\r\nreplicaset.apps/k8shelloboot-app-deploy-7f67896bf7   1         1         1       7s\n일단 pod 의 상태를 보면 정상적으로 Running 상태에 진입했다는 사실을 확인했습니다.\n이번에는 pod 내부로 접속해서 API가 잘 동작하는지 로그가 잘 찍혔는지 확인해봅니다. Service와 Ingress 를 모두 만들어서 호스트 PC에서 확인해보면 멋있어보이겠지만, 개념설명의 호흡이 길어져서 요지를 알 수 없을 수 있기에 pod에 접속해서 직접 로그를 확인하는 방식으로 동작을 확인해봅니다.\n## pod 접속\r\n$ kubectl exec -it k8shelloboot-app-deploy-7f67896bf7-wqxs9 -- bash\r\nbash-4.2#\r\n...\r\n\r\n## API 호출 시 정상응답하는지 확인\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n...\r\n\r\n## 로그파일 내용 확인\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-02-01T08:47:51.183360936>>> write OK\r\n...\r\n\r\n## API 호출 시 정상응답하는지 확인\r\nbash-4.2# curl http://localhost:8080/healthcheck\r\nOK\r\n\r\n## 로그파일 내용 확인 (로그파일에 모두 잘 기록되었다.)\r\nbash-4.2# cat /app/volume/cache-log.log\r\n2024-02-01T08:47:51.183360936>>> write OK\r\n2024-02-01T08:48:19.245463098>>> write OK"}},"/storage/window-directory-k8s-mount":{"title":"kubernetes hostPath 지정시 윈도우 WSL 디렉터리 경로","data":{"참고자료#참고자료":"Kubernetes on docker for windows, persistent volume with hostPath gives Operation not permitted\nWSL2 Kubernetes 환경에서 Windows 경로 Mount 하기\nKubernetes how to correctly mount windows path in wsl2 backed environment\nWindows 10 20H2 Docker Desktop WSL2 enable 환경에서 Kubernetes volume hostPath 연결 오류 해결\nKubernetes on docker for windows, persistent volume with hostPath gives Operation not permitted\nwsl2 kubernetes volume hostpath 못잡는 문제 해결방법\nhttps://www.inflearn.com/questions/98495/access-i-s-denied-문제\nError response from daemon: mkdir C:\\Program Files\\Git\\opt: Access is denied\npath for PersistentVolume in Kubernetes .yaml in Windows","윈도우os-에서-hostpath-경로#윈도우OS 에서 hostPath 경로":"쿠버네티스 역시 결국은 Docker 엔진으로 동작하는데, 윈도우 기반의 Docker 엔진에서 WSL 의 어느 디렉터리를 참조하는지가 꽤 까다롭습니다.\r\n디렉터리를 참조하는 경로는 아래와 같이 구성됩니다.\n/run/desktop/mnt/host/c/PATH/TO/FILE\n예를 들어 HOST PC 의 /v/000.env/volume 을 파드 내에서 마운트할 때 hostPath 의 path 는 아래와 같이 지정해줍니다.\n/run/desktop/mnt/host/v/000.env/volume"}}}